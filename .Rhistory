rm(list = ls())
getwd()
setwd("~/GitHub/SporeMut")
require("bbmle")
require("grid")
require("png")
# I installed jags first from here: https://sourceforge.net/projects/mcmc-jags/
library("rjags") # external program for mcmc
library("rjags") # external program for mcmc
sem <- function(x, ...){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}
data <- read.table("data/1.PopDynamics/spore.transition.txt", header = TRUE)
head(data)
colnames(data)[1] <- "time.h"
time.d <- data$time/24
data <- data.frame(data[1],time.d,data[2:6])
data
# put in same scale but keep to reasonable number to not put too much pressure on the prior
# tot.ab <- data$total * 10^(data$total_dil) *10 # original
tot.ab <- data$total * 10^(data$total_dil+1) / 10^(4)
# calculate spore CFUs using dilution (per 1000 uL dilution)
# multiply be 10 to go from 100 ul dilution to 1 mL
# spo.ab <- data$spore * 10^(data$spor_dil) * 10
spo.ab <- data$spore * 10^(data$spor_dil+1)/ 10^(4)
# calculate veg CFUs using dilution
veg.ab <- tot.ab - spo.ab
# calculate proportion of vegetative CFUs
prop.veg <- 1 - (spo.ab / tot.ab)
# calculate proportion of spore CFUs
prop.spor <- 1 - prop.veg
# make new data frame
trans <- data.frame(data, tot.ab, veg.ab, spo.ab, prop.veg, prop.spor)
trans.A <- trans[ which(trans$rep == 'A'), ]
trans.A.neg <- sum(trans.A$veg.ab <0) # 8 negative values
trans.B <- trans[ which(trans$rep == 'B'), ]
trans.B.neg <- sum(trans.B$veg.ab <0) # 9 negative values
trans.C <- trans[ which(trans$rep == 'C'), ]
trans.C.neg <- sum(trans.C$veg.ab <0) # 22 negative values
trans.D <- trans[ which(trans$rep == 'D'), ]
trans.D.neg <- sum(trans.D$veg.ab <0) # 26 negative values
# Data from end of LTDE
end.data <- read.table("data/1.PopDynamics/spore.transition.ltde.txt", header = TRUE)
head(end.data)
time.end.d <- end.data$time.h/24
end.data <- data.frame(end.data[1],time.end.d,end.data[2:6])
end.tot.ab <- end.data$total * 10^(end.data$total_dil) * 10
end.spo.ab <- end.data$spore * 10^(end.data$spor_dil) * 10
end.veg.ab <- end.tot.ab - end.spo.ab
end.prop.veg <- 1 - (end.spo.ab / end.tot.ab)
end.prop.spor <- 1 - end.prop.veg
end.data.sum <-data.frame(end.data$time.end.d, end.spo.ab, end.veg.ab)
colnames(end.data.sum) <- c("time", "spore", "veg")
end.data
trans.rep <- trans.A
# Observed total (T) and spore (S) abundances from CFU counts
T_obs <- trans.rep$tot.ab
S_obs <- trans.rep$spo.ab
S_par.eq <- exp(solve(matrix(c(1,1,-1,-2),2,2), matrix(log(c(mean(S_obs[trans.rep$time.h>240]),
var(S_obs[trans.rep$time.h>240]))),2,1)))
S_par.tr <- exp(solve(matrix(c(1,1,-1,-2),2,2), matrix(log(c(mean(S_obs[trans.rep$time.h<240]),
var(S_obs[trans.rep$time.h<240]))),2,1)))
V_est <- (T_obs-S_obs)[which((T_obs-S_obs)>0)]
V_par.eq <- exp(solve(matrix(c(1,1,-1,-2),2,2),
matrix(log(c(mean(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]>240]),
var(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]>240]))),2,1)))
V_par.tr<- exp(solve(matrix(c(1,1,-1,-2),2,2),
matrix(log(c(mean(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]<240]),
var(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]<240]))),2,1)))
# Spore - equilibrium phase
hist(S_obs[trans.rep$time.h>240], freq = F)
curve(dgamma(x, S_par.eq[1], S_par.eq[2]), from = min(S_obs), to = max(S_obs), add = T)
hist(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]>240], freq = F)
curve(dgamma(x,V_par.eq[1], V_par.eq[2]),
from =min(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]>240]),
to = max(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]>240]), add = T)
hist(S_obs[trans.rep$time.h<240], freq = F)
curve(dgamma(x, S_par.tr[1], S_par.tr[2]), from = min(S_obs), to = max(S_obs), add = T)
hist(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]<240], freq = F)
curve(dgamma(x,V_par.tr[1], V_par.tr[2]),
from = min(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]<240]),
to = max(V_est[trans.rep$time.h[which((T_obs-S_obs)>0)]<240]), add = T)
mod<-"model{
for(i in 1:19){
V[i]~dgamma(v_alpha1,v_beta1)
S[i]~dgamma(s_alpha1,s_beta1)
# Set up observation model as acutal values plus observation error
Sobs[i]~dnorm(S[i],tau.to)
Tobs[i]~dnorm(V[i]+S[i],tau.so)
}
for(i in 20:n){
V[i]~dgamma(v_alpha2,v_beta2)
S[i]~dgamma(s_alpha2,s_beta2)
# Set up observation model as acutal values plus observation error
Sobs[i]~dnorm(S[i],tau.to)
Tobs[i]~dnorm(V[i]+S[i],tau.so)
}
# Set some priors (what decisions are made here?)
sig.v~dunif(0,1000)
tau.v <- pow(sig.v,-2)
sig.s~dunif(0,1000)
tau.s <- pow(sig.v,-2)
sig.so~dunif(0,1000)
sig.to~dunif(0,1000)
tau.so <- pow(sig.so,-2)
tau.to <- pow(sig.to,-2)
}"
jdata <- list('n' = nrow(trans.rep), 'Sobs' = S_obs, "Tobs" = T_obs, "v_alpha1" = V_par.tr[1],
"v_beta1" = V_par.tr[2], "s_alpha1" = S_par.tr[1], "s_beta1" = S_par.tr[2],"v_alpha2" = V_par.eq[1],
"v_beta2" = V_par.eq[2], "s_alpha2" = S_par.eq[1], "s_beta2" = S_par.eq[2])
# Initialize the model
tot.mod <- jags.model(textConnection(mod), data = jdata, n.chains = 5)
update(tot.mod, 1000)
# Get samples from it for what we are interested: V, S and the obs errors
# Creates output with n.iter samples per chain
fit.mod <- coda.samples(tot.mod, c('V','S','sig.to','sig.so'), n.iter = 5000)
# Get summary of our 5 chains (i.e., number of Markov chains)
f <- summary(fit.mod)
r
f
# Look at S values
f$statistics[grep("S",rownames(f$statistics)),]
f$quantiles[grep("S",rownames(f$quantiles)),]
# Look at V values
f$statistics[grep("V",rownames(f$statistics)),]
f$quantiles[grep("V",rownames(f$quantiles)),]
time <- trans.rep$time.d
s.est <- f$statistics[grep("S",rownames(f$statistics)),1]
v.est <- f$statistics[grep("V",rownames(f$statistics)),1]
s.lower <- f$quantiles[grep("S",rownames(f$quantiles)),1]
s.upper <- f$quantiles[grep("S",rownames(f$quantiles)),5]
v.est <- f$statistics[grep("V",rownames(f$statistics)),1]
v.lower <- f$quantiles[grep("V",rownames(f$quantiles)),1]
v.upper <- f$quantiles[grep("V",rownames(f$quantiles)),5]
data2 <- data.frame(time, s.est,s.lower,s.upper, v.est,v.lower,v.upper)
#write.table(data2, "data/transition.Bayes.repD.txt", sep = "\t", col.names = T, row.names = F)
write.table(data2, "output/1.PopDynamics/transition.Bayes.repA.txt", sep = "\t", col.names = T, row.names = F)
data.B.A <- read.table("output/1.PopDynamics/transition.Bayes.repA.txt", header = TRUE)
data.B.A <- read.table("output/1.PopDynamics/transition.Bayes.repA.txt", header = TRUE)
data.B.B <- read.table("output/1.PopDynamics/transition.Bayes.repB.txt", header = TRUE)
data.B.C <- read.table("output/1.PopDynamics/transition.Bayes.repC.txt", header = TRUE)
data.B.D <- read.table("output/1.PopDynamics/transition.Bayes.repC.txt", header = TRUE)
data.B <- data.frame(data.B.A[,c(1:2,5)], data.B.B[,c(2,5)], data.B.C[,c(2,5)], data.B.D[,c(2,5)])
colnames(data.B) <- c("time", "Spore.A", "Veg.A", "Spore.B", "Veg.B", "Spore.C", "Veg.C", "Spore.D", "Veg.D")
S.mean <- apply(data.frame(data.B$Spore.A, data.B$Spore.B, data.B$Spore.C, data.B$Spore.D), 1, mean) * 10^4
data.all <- rbind(data.B.A[,c(1:2,5)], data.B.B[,c(1:2,5)], data.B.A[,c(1:2,5)], data.B.A[,c(1:2,5)])
data.all <- data.frame(data.all[,1], (10^4 * data.all[,2:3]))
colnames(data.all) <- c("time", "spore", "veg")
S.sem <- apply(data.frame(data.B$Spore.A, data.B$Spore.B, data.B$Spore.C, data.B$Spore.D), 1, sem) * 10^4
V.mean <- apply(data.frame(data.B$Veg.A, data.B$Veg.B, data.B$Veg.C, data.B$Veg.D), 1, mean) * 10^4
V.sem <- apply(data.frame(data.B$Veg.A, data.B$Veg.B, data.B$Veg.C, data.B$Veg.D), 1, sem) * 10^4
data.all
end.data
time.end.d
1910/60
1910/365
data
View(data)
View(data)
897.8/365
