---
title: "Growth Curves"
author: "Jay T. Lennon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
  - \usepackage{array}
output: pdf_document
geometry: margin=2.54cm
editor_options: 
  chunk_output_type: console
---

## Clear workspace and set directory
```{r setup}
rm(list=ls())
#setwd("~/Github/SporeMut/code/4.GrowthCurves/test")
setwd("~/Github/SporMut/code/4.GrowthCurves/test")
```

## Load packages and functions
```{r}
require("png")
require("dplyr")
require("grid")
require("gtools")
require("nlme")
require("MuMIn")
require("bbmle")
#source("~/Github/SporeMut/code/4.GrowthCurves/bin/modified_Gomp_diagnostic3.R")
source("~/Github/SporMut/code/4.GrowthCurves/bin/modified_Gomp_diagnostic3.R")
sem <- function(x) sqrt(var(x)/length(x))
cv <- function(x) 100*( sd(x)/mean(x))
LL.95 <- function(x) t.test(x)$conf.int[1]
UL.95 <- function(x) t.test(x)$conf.int[2]

# Update - Canan
require(tidyverse) #ggplot,dplyr, dependencies  
require(ggh4x) #ggplot tricks
require(scales) #ggplot scaling axes
require(lme4) #linear mixed effect models
require(emmeans) #marginal means
require(multcomp) #multiple comparisons
require(multcompView) #multiple comparisons
require(optimx) #optimizer for lmer
require(afex) #for p values
require(jtools) #plot model results
require(patchwork) #to combine plots 

# For Bayesian stats 
require("rstan")
require("devtools")
#install_github("paul-buerkner/brms")
library(brms)
devtools::install_github("strengejacke/sjstats")
library(bayestestR)
library(bayesplot) #plotting posteriors


# After Don 
# Jags version 
library(rjags)
library(ggridges)
```

## Load data
```{r}
# Load data and change time to numeric
# dat <- read.csv("~/Github/SporeMut/code/4.GrowthCurves/data/batch_combo.csv")
# dat <- cbind(dat1,dat2)
# anc <-read.csv("~/Github/SporeMut/code/4.GrowthCurves/data/ancestor.csv")
# anc$Time <- as.numeric(sub("^(\\d+):(\\d+).*", "\\1.\\2", anc$Time))
# dat <- read.csv("~/Github/SporeMut/code/4.GrowthCurves/data/20230802_GrowthCurve_SporeMut.csv")

#dat <- read.csv("~/Github/SporeMut/code/4.GrowthCurves/data/20230821_GrowthCurve_SporeMut.csv")
dat  <- read.csv("~/Github/SporMut/code/4.GrowthCurves/data/20230821_GrowthCurves_SporeMut.csv")
dat2 <- read.csv("~/Github/SporMut/code/4.GrowthCurves/data/20230822_SporeMut_GrowthCurves_R2B.csv")
dat3 <- read.csv("~/Github/SporMut/code/4.GrowthCurves/data/20230823_SporeMut_GrowthCurves_R2B.csv")
dat4 <- read.csv("~/Github/SporMut/code/4.GrowthCurves/data/20230824_SporeMut_GrowthCurves_R2B.csv")
dat5 <- read.csv("~/Github/SporMut/code/4.GrowthCurves/data/20230826_SporeMut_GrowthCurves_R2B.csv")

dat$Time <- as.numeric(sub("^(\\d+):(\\d+).*", "\\1.\\2", dat$Time))
# filter so length of data is equal across strains
#dat <- dat.raw %>% 
# filter(row_number() <= 93) 

dat2$Time <- as.numeric(sub("^(\\d+):(\\d+).*", "\\1.\\2", dat2$Time))
dat3$Time <- as.numeric(sub("^(\\d+):(\\d+).*", "\\1.\\2", dat3$Time))
dat4$Time <- as.numeric(sub("^(\\d+):(\\d+).*", "\\1.\\2", dat4$Time))
dat5$Time <- as.numeric(sub("^(\\d+):(\\d+).*", "\\1.\\2", dat5$Time))
```

## To skip following chunks, read this data 
```{r}
input_dat <- read.csv("~/Github/SporMut/code/4.GrowthCurves/data/comp_data.csv")
```

## Run Gompertz model - Do not run if you already have the outputs -> Read outputs
```{r}
# Slow process: comment out line below after running
# Here, read in each strain one-at-a-time (helps with troubleshooting fits)

anc <- dat %>%
  dplyr::select(Time, starts_with("ancestor"))
anc.fits <-growth.modGomp(input = anc, output.name = "anc_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M4 <- dat %>%
  dplyr::select(Time, starts_with("M4_"))
M4.fits <-growth.modGomp(input = M4, output.name = "M4_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S1 <- dat %>%
  dplyr::select(Time, starts_with("S1_"))
S1.fits <-growth.modGomp(input = S1, output.name = "S1_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)
S1.fits.out <- read.table("../output/S1_new.fit.parms.txt", sep = ",", header = TRUE)

M23 <- dat %>%
  dplyr::select(Time, starts_with("M23_"))
M23.fits <-growth.modGomp(input = M23, output.name = "M23_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M13 <- dat2 %>%
  dplyr::select(Time, starts_with("M13_"))
M13.fits <-growth.modGomp(input = M13, output.name = "M13_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M17 <- dat2 %>%
  dplyr::select(Time, starts_with("M17_"))
M17.fits <-growth.modGomp(input = M17, output.name = "M17_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M19 <- dat2 %>%
  dplyr::select(Time, starts_with("M19_"))
M19.fits <-growth.modGomp(input = M19, output.name = "M19_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)
M19.fits.out <- read.table("../output/M19_new.fit.parms.txt", sep = ",", header = TRUE)

M21 <- dat2 %>%
  dplyr::select(Time, starts_with("M21_"))
M21.fits <-growth.modGomp(input = M21, output.name = "M21_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M26 <- dat2 %>%
  dplyr::select(Time, starts_with("M26_"))
M26.fits <-growth.modGomp(input = M26, output.name = "M26_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M41 <- dat2 %>%
  dplyr::select(Time, starts_with("M41_"))
M41.fits <-growth.modGomp(input = M41, output.name = "M41_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M54 <- dat2 %>%
  dplyr::select(Time, starts_with("M54_"))
M41.fits <-growth.modGomp(input = M54, output.name = "M54_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M79 <- dat2 %>%
  dplyr::select(Time, starts_with("M79_"))
M79.fits <-growth.modGomp(input = M79, output.name = "M79_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S6 <- dat2 %>%
  dplyr::select(Time, starts_with("S6_"))
S6.fits <-growth.modGomp(input = S6, output.name = "S6_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)
S6.fits.out <- read.table("../output/S6_new.fit.parms.txt", sep = ",", header = TRUE)

S11 <- dat2 %>%
  dplyr::select(Time, starts_with("S11_"))
S11.fits <-growth.modGomp(input = S11, output.name = "S11_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S22 <- dat3 %>%
  dplyr::select(Time, starts_with("S22_"))
S22.fits <-growth.modGomp(input = S22, output.name = "S22_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S51 <- dat3 %>%
  dplyr::select(Time, starts_with("S51_"))
S51.fits <-growth.modGomp(input = S51, output.name = "S51_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S95 <- dat3 %>%
  dplyr::select(Time, starts_with("S95_"))
S95.fits <-growth.modGomp(input = S95, output.name = "S95_new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

#fits.anc <- growth.modGomp(input = anc, output.name = "fit.anc.parms",
#        synergy = F, temp = F, smooth = T, trim = T)
#fits.anc.out <- read.table("../output/fit.anc.parms.txt", sep = ",", header = TRUE)
#treat.anc <- read.csv("../data/treatments.anc.csv")
#anc.parms <- data.frame(treat.anc, fits.anc.out)
```

## Read outputs
```{r}
M4.fits.out  <- read.table("../output/M4_new.fit.parms.txt", sep = ",", header = TRUE)
anc.fits.out <- read.table("../output/anc_new.fit.parms.txt", sep = ",", header = TRUE)
M23.fits.out <- read.table("../output/M23_new.fit.parms.txt", sep = ",", header = TRUE)
M13.fits.out <- read.table("../output/M13_new.fit.parms.txt", sep = ",", header = TRUE)
M17.fits.out <- read.table("../output/M17_new.fit.parms.txt", sep = ",", header = TRUE)
M19.fits.out <- read.table("../output/M19_new.fit.parms.txt", sep = ",", header = TRUE)
M21.fits.out <- read.table("../output/M21_new.fit.parms.txt", sep = ",", header = TRUE)
M26.fits.out <- read.table("../output/M26_new.fit.parms.txt", sep = ",", header = TRUE)
M54.fits.out <- read.table("../output/M54_new.fit.parms.txt", sep = ",", header = TRUE)
M41.fits.out <- read.table("../output/M41_new.fit.parms.txt", sep = ",", header = TRUE)
M79.fits.out <- read.table("../output/M79_new.fit.parms.txt", sep = ",", header = TRUE)
S1.fits.out  <- read.table("../output/S1_new.fit.parms.txt", sep = ",", header = TRUE)
S6.fits.out  <- read.table("../output/S1_new.fit.parms.txt", sep = ",", header = TRUE)
S11.fits.out <- read.table("../output/S11_new.fit.parms.txt", sep = ",", header = TRUE)
S22.fits.out <- read.table("../output/S22_new.fit.parms.txt", sep = ",", header = TRUE)
S51.fits.out <- read.table("../output/S51_new.fit.parms.txt", sep = ",", header = TRUE)
S95.fits.out <- read.table("../output/S95_new.fit.parms.txt", sep = ",", header = TRUE)
```

## Repeated growth curves- Do not run if you already have the outputs -> Read repeated outputs 
```{r}
# Repeated growth curves 
M13.R <- dat4 %>%
  dplyr::select(Time, starts_with("M13_"))
M13.R.fits <-growth.modGomp(input = M13.R, output.name = "M13_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M17.R <- dat4 %>%
  dplyr::select(Time, starts_with("M17_"))
M17.R.fits <-growth.modGomp(input = M17.R, output.name = "M17_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M21.R <- dat4 %>%
  dplyr::select(Time, starts_with("M21_"))
M21.R.fits <-growth.modGomp(input = M21.R, output.name = "M21_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M23.R <- dat4 %>%
  dplyr::select(Time, starts_with("M23_"))
M23.R.fits <-growth.modGomp(input = M23.R, output.name = "M23_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M54.R <- dat4 %>%
  dplyr::select(Time, starts_with("M54_"))
M54.R.fits <-growth.modGomp(input = M54.R, output.name = "M54_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S1.R <- dat4 %>%
  dplyr::select(Time, starts_with("S1_"))
S1.R.fits <-growth.modGomp(input = S1.R, output.name = "S1_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S11.R <- dat4 %>%
  dplyr::select(Time, starts_with("S11_"))
S11.R.fits <-growth.modGomp(input = S11.R, output.name = "S11_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S22.R <- dat4 %>%
  dplyr::select(Time, starts_with("S22_"))
S22.R.fits <-growth.modGomp(input = S22.R, output.name = "S22_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S51.R <- dat4 %>%
  dplyr::select(Time, starts_with("S51_"))
S51.R.fits <-growth.modGomp(input = S51.R, output.name = "S51_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

S95.R <- dat4 %>%
  dplyr::select(Time, starts_with("S95_"))
S95.R.fits <-growth.modGomp(input = S95.R, output.name = "S95_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M4.R <- dat5 %>%
  dplyr::select(Time, starts_with("M4_"))
M4.R.fits <-growth.modGomp(input = M4.R, output.name = "M4_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M19.R <- dat5 %>%
  dplyr::select(Time, starts_with("M19_"))
M19.R.fits <-growth.modGomp(input = M19.R, output.name = "M19_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M23.R2 <- dat5 %>%
  dplyr::select(Time, starts_with("M23_"))
M23.R2.fits <-growth.modGomp(input = M23.R2, output.name = "M23_repeat2.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M26.R <- dat5 %>%
  dplyr::select(Time, starts_with("M26_"))
M26.R.fits <-growth.modGomp(input = M26.R, output.name = "M26_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)

M41.R <- dat5 %>%
  dplyr::select(Time, starts_with("M41_"))
M41.R.fits <-growth.modGomp(input = M41.R, output.name = "M41_repeat.new.fit.parms",
        synergy = F, temp = F, smooth = T, trim = T)
```

## Read repeated outputs 
```{r}
M13.R.fits.out  <- read.table("../output/M13_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
M17.R.fits.out  <- read.table("../output/M17_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
M21.R.fits.out  <- read.table("../output/M21_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
M23.R.fits.out  <- read.table("../output/M23_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
M54.R.fits.out  <- read.table("../output/M54_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
S1.R.fits.out   <- read.table("../output/S1_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
S11.R.fits.out  <- read.table("../output/S11_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
S22.R.fits.out  <- read.table("../output/S22_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
S51.R.fits.out  <- read.table("../output/S51_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
S95.R.fits.out  <- read.table("../output/S95_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
M4.R.fits.out   <- read.table("../output/M4_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
M19.R.fits.out  <- read.table("../output/M19_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
M23.R2.fits.out <- read.table("../output/M23_repeat2.new.fit.parms.txt", sep = ",", header = TRUE)
M26.R.fits.out  <- read.table("../output/M26_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
M41.R.fits.out  <- read.table("../output/M41_repeat.new.fit.parms.txt", sep = ",", header = TRUE)
```

## Subset the best 6 curves of each clone based on RMSE
```{r}
# Subset the best 6 curves of each clone 
# Removing non fitting models and and selecting 6 of them 
# where RMSE smaller.

# anc.fits.out
M4_all  <- rbind.data.frame(M4.fits.out, M4.R.fits.out)
M13_all <- rbind.data.frame(M13.fits.out[-c(1,6),], M13.R.fits.out)
M17_all <- rbind.data.frame(M17.fits.out[-1,], M17.R.fits.out[-c(2,5,6),])
M19_all <- rbind.data.frame(M19.fits.out, M19.R.fits.out[-c(2,10),])
M21_all <- rbind.data.frame(M21.fits.out[-c(2,6),], M21.R.fits.out)
M23_all <- rbind.data.frame(M23.R.fits.out, M23.R2.fits.out)
M26_all <- rbind.data.frame(M26.fits.out, M26.R.fits.out[-1,])
#M41.fits.out
M54_all <- rbind.data.frame(M54.fits.out[-3,], M54.R.fits.out[-c(2,4),])
#M79.fits.out
S1_all  <- rbind.data.frame(S1.fits.out[-5,], S1.R.fits.out)
#S6.fits.out
S11_all <- rbind.data.frame(S11.fits.out, S11.R.fits.out)
S22_all <- rbind.data.frame(S22.fits.out[-c(3,4),], S22.R.fits.out)
S51_all <- rbind.data.frame(S51.fits.out, S51.R.fits.out)
S95_all <- rbind.data.frame(S95.fits.out, S95.R.fits.out)

#choose rhe first 6 lowest RSME

dflist <- list(anc.fits.out, M4_all, M13_all, M17_all, M19_all, M21_all,
            M23_all, M26_all, M41.fits.out, M54_all,
            M79.fits.out, S1_all,S6.fits.out, S11_all, 
            S22_all, S51_all, S95_all)

bestCurve <- function(x){
  x[x$RSME %in% sort(x$RSME, partial = 1:6)[1:6], ] 
}

dflist_best <- lapply(dflist, bestCurve)

# M13.reps <- M13_all$umax[abs(M13_all$umax-median(M13_all$umax)) %in% sort(abs(M13_all$umax-median(M13_all$umax)), partial=1:6)[1:6]]
# M13.all.out <- M13_all[M13_all$umax %in% M13.reps, ]  

```

## Merge with treatment data - Fixed
```{r}
all.fits <- bind_rows(dflist_best, .id = "column_label")

all.fits$clones <- gsub("_.*","",all.fits$Curve)
all.fits$clones[1:6] <- rep("ancestor", time = 6)

# Combine fits with strain and treatment information (e.g, cell type, mutations, etc.)
treats <- read.csv("~/Github/SporMut/code/4.GrowthCurves/data/treatments_original_corrected.csv")

# The correct file is treatments_original.csv, I added ancestor and changed some factor level names and
# saved as treatments_original_corrected.csv
#parms <- data.frame(treats, all.fits) 
# this doesn't work, probably because some of the fits didn't converge?
# It is because some clones have different amount of reps 
# Also it is the wrong file.  
# Another thing I'd avoid cbind. Safest way is binding with ID column

all.fits.treats <- all.fits %>%
  left_join(treats, by = "clones")

write.csv(all.fits.treats, "comp_data.csv", row.names=FALSE)
```

## Wrangle dplyr/ggplot version - Canan
```{r}
# column
# filter spores
treats_param <-  all.fits.treats %>%
  filter(!evo.type == "spore") %>%
mutate(clone = tolower(clones)) %>%
  mutate (mutation = recode(mutation, nomut = 'ancestor', spormut = 'spore'))
write.csv(treats_param, "growthData")

# summarize 
sum_treats_param <-  treats_param %>%
      group_by(clone, evo.type, cell.type, mutation) %>%
      summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L), sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L), LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L), UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L)) %>%
            ungroup()

# order factor levels
sum_treats_param$clone <- factor(sum_treats_param$clone, levels = c("ancestor", "m23","m26","m17", "m19", "m21", "m41", "m54", "m4", "m13", "m79")) 

treats_param$clone <- factor(treats_param$clone, levels = c("ancestor", "m23","m26","m17", "m19", "m21", "m41", "m54", "m4", "m13", "m79")) 

ggplot(sum_treats_param, aes(x = weave_factors(clone, mutation, evo.type, cell.type), y = mean_umax, group = interaction(clone, mutation)))+
  geom_point(shape = 1, size = 4, color = "black", position = position_dodge(0.5))+
  geom_point(data = treats_param, aes(x = weave_factors(clone, mutation, evo.type, cell.type), y = umax, group = interaction(clone, mutation)), position = position_dodge(0.5), alpha = .3, size = 4, color = "grey")+
  geom_errorbar(data = sum_treats_param, aes (ymin = (mean_umax - sem_umax), ymax = (mean_umax + sem_umax),group = interaction(clone, mutation)), width = .2, color = "black", position = position_dodge(0.5))+
  ylab("Maximum growth rate")+
  #scale_x_discrete(limits = level_order)+
  #facet_wrap(~treatment, ncol = 4, scales = "free_x", drop = TRUE)+
  theme_bw()+
  theme(legend.position = 'bottom')+
  theme(axis.ticks.length=unit(.25, "cm"))+
  theme(legend.title = element_blank(), legend.text = element_text(size=12))+
  theme(axis.text = element_text(size = 14), 
  axis.title.x = element_blank(), axis.title.y = element_text(size =14))+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  force_panelsizes(cols = c(0.3, 0.6, 1.18, 0.9))+
  guides(x = "axis_nested")+
  scale_x_discrete(guide = guide_axis_nested(delim = "!"))+
  guides(x.sec = guide_axis_manual(
    breaks = ~., seq_len(nrow(sum_treats_param)), labels = NULL))+
      guides(y.sec = guide_axis_manual(
    breaks = c(0.15, 0.13, 0.11, 0.09, 0.07), labels = NULL))
```
## Remake Megan's figure for the manuscript - Canan
```{r}
treats_param_long <- treats_param %>%
  dplyr::select(b0, A, umax, L, evo.type, cell.type, mutation, clone) %>%
  pivot_longer(cols = c(b0, A, umax, L), names_to = "parameter", values_to = "value") %>%
  mutate (mutation = recode(mutation, nomut = 'ancestor', spormut = 'spore'))

treats_param_se <- treats_param %>%
  dplyr::select(b0.se, A.se, umax.se, L.se, mutation) %>%
  pivot_longer(cols = c(b0.se, A.se, umax.se, L.se), names_to = "parameter", values_to = "value") %>%
  group_by(mutation, parameter) %>%
  summarise(meanerror = mean(value)) %>%
  mutate (mutation = recode(mutation, nomut = 'ancestor', spormut = 'spore'))

treats_param_sum <- treats_param_long %>%
  group_by(mutation, parameter, evo.type, cell.type) %>%
  summarise(meanvalue = mean(value)) %>%
  ungroup() %>% 
  bind_cols(meanerror = treats_param_se$meanerror) %>%
  mutate (mutation = recode(mutation, nomut = 'ancestor', spormut = 'spore'))


ggplot(treats_param_sum, aes(x = mutation, y = meanvalue, color = mutation))+
  geom_jitter(data = treats_param_long, aes(x = mutation, y = value), alpha = .3)+
  geom_point(aes(x = mutation, y = meanvalue), size = 5, shape = 1, stroke = 1)+
  facet_wrap(~parameter, scales = "free")+
  geom_errorbar(aes(ymin = (meanvalue - meanerror), 
                 ymax = (meanvalue + meanerror)), width = .2, linewidth = 0.8)+
  theme_bw()+
  theme(legend.position = 'bottom')+
  theme(axis.ticks.length=unit(.25, "cm"))+
  theme(legend.title = element_blank(), legend.text = element_text(size=12))+
  theme(axis.text = element_text(size = 14), 
  axis.title.x = element_blank(), axis.title.y = element_text(size = 14))+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  theme(axis.text.x = element_blank())+
  theme(strip.text.x = element_text(size = 14))+
  scale_color_manual(values = c("#E64B35","#4DBBD5","#3C5488","#F39B7F"))
  
``` 

## Stats - Canan - Mutation comparisons
```{r}
set.seed(1010350)

treats_param$mutation <- as.factor(treats_param$mutation)
contrasts(treats_param$mutation) <- contr.treatment(4, base = 1)  # Treat Control as the reference level
custom_contrasts <- matrix(c(0, 0, 0, 1, 0, 0,0, 1, 0, 0, 0, 1), nrow = 4, ncol = 3, byrow = T)

#Carrying capacity 
mod1 <- lmer(A ~ mutation + (1|clones) , data = treats_param, REML = F, 
          control = lmerControl(optimizer ='optimx', optCtrl = list(method='nlminb')), contrasts = list(mutation = custom_contrasts))
summary(mod1)

emm_mut1 <- emmeans(mod1, ~mutation)
c1 <- contrast(emm_mut1, "trt.vs.ctrl")

#Lag time
mod3 <- lmer(L ~ mutation + (1|clones) , data = treats_param, REML = F, 
          control = lmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')), contrasts = list(mutation = custom_contrasts))
summary(mod3)

emm_mut3 <- emmeans(mod3, "mutation")
c3 <- contrast(emm_mut3, "trt.vs.ctrl")

#Max. growth rate
mod4 <- lmer(umax ~ mutation + (1|clones) , data = treats_param, REML = F, 
          control = lmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')), contrasts = list(mutation = custom_contrasts))
summary(mod4)

emm_mut4 <- emmeans(mod4, "mutation")
c4 <- contrast(emm_mut4, "trt.vs.ctrl")


dataPlot <- rbind.data.frame(as.data.frame(emm_mut1),
                             as.data.frame(emm_mut3), 
                             as.data.frame(emm_mut4))
                             
dataPlot$parameter <- rep(c('K', 'lag', 'umax'), each = 4)

dataPlotN <- cbind.data.frame(mutation = dataPlot$mutation, mean = dataPlot$emmean, se = dataPlot$SE, parameter = dataPlot$parameter)

dataContrast <- rbind.data.frame(as.data.frame(c1),
                             as.data.frame(c3), 
                             as.data.frame(c4))

dataContrast$parameter <- rep(c('K', 'lag', 'umax'), each = 3)

contrastPlot <- cbind.data.frame(contrast = dataContrast$contrast, estimate = dataContrast$estimate, se = dataContrast$SE, p.value = dataContrast$p.value, 
                                 parameter = dataContrast$parameter)

treats_param_rel <- treats_param_long %>%
  filter(!parameter == "b0") %>%
   mutate(parameter = recode(parameter, A = "K", L = "lag"))
  
#Lag - ancestor-spore and ancestor-sinR significant 
ggplot(dataPlotN, aes(x = mutation, y = mean), color ="grey20")+
  geom_jitter(data = treats_param_rel, aes(x = mutation, y = value, color = clone, fill = clone), alpha = .5, shape = 21)+
  geom_point(aes(x = mutation, y = mean), size = 5, shape = 1, stroke = 1)+
  facet_wrap(~parameter, scales = "free")+
  geom_errorbar(aes(ymin = (mean - se), 
                 ymax = (mean + se)), width = .2, linewidth = 0.8)+
  theme_bw()+
  theme(legend.position = 'none')+
  theme(axis.ticks.length=unit(.25, "cm"))+
  theme(legend.title = element_blank(), legend.text = element_text(size=12))+
  theme(axis.text = element_text(size = 14), 
  axis.title.x = element_blank(), axis.title.y = element_text(size = 14))+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  theme(strip.text.x = element_text(size = 14))+
  scale_color_manual(values = c("#E64B35","#4DBBD5","#3C5488","#F39B7F", 
                                "#00A087", "#7E6148", "thistle3", 
                                "goldenrod1", "darkkhaki", "coral4", 
                                "skyblue4"))+
  scale_fill_manual(values = c("#E64B35","#4DBBD5","#3C5488","#F39B7F", 
                                "#00A087", "#7E6148", "thistle3", 
                                "goldenrod1", "darkkhaki", "coral4", 
                                "skyblue4"))+
   scale_y_continuous(labels = label_number(accuracy = 0.01))
```

## Stats - Canan - Clone comparisons 
```{r}
K <- lm(A ~ clone, data = treats_param)
summary(K)
emm_m1 <- emmeans(K, ~clone)
con1 <- contrast(emm_m1, "trt.vs.ctrl")

umax <- lm(umax ~ clone, data = treats_param)
summary(umax)
emm_m2 <- emmeans(umax, ~clone)
con2 <- contrast(emm_m2, "trt.vs.ctrl")

lag <- lm(L ~ clone, data = treats_param)
summary(lag)
emm_m3 <- emmeans(lag, ~clone)
con3 <- contrast(emm_m3, "trt.vs.ctrl")

plotK <- plot_summs(K, robust = T, plot.distributions = TRUE, colors = '#3C5488')+
  theme_bw()+
  theme(legend.position = 'none')+
  theme(axis.ticks.length = unit(.25, "cm"))+
  theme(legend.text = element_text(size=12))+
  theme(axis.text = element_text(size = 14), axis.title.y = element_text(size = 14), axis.title.x = element_text(size = 14))+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  theme(strip.text.x = element_text(size = 14))+
  scale_y_discrete(labels = c('m79','m54','m41','m26','m23','m21','m19','m17','m13','m4'))+
  ylab("Clone ID")+
  scale_x_continuous(breaks = c(-0.10,-0.05, 0, 0.05, 0.10), labels = c(-1.10,-1.05, 1, 1.05, 1.10))+
  xlab("Relative change")+
  ggtitle("K")+
  scale_color_manual(values = "grey25")
  
plotUmax <- plot_summs(umax, robust = T, plot.distributions = TRUE, colors = '#3C5488')+
  theme_bw()+
  theme(legend.position = 'none')+
  theme(axis.ticks.length = unit(.25, "cm"))+
  theme(legend.text = element_text(size=12))+
  theme(axis.text = element_text(size = 14), axis.title.y = element_text(size = 14), axis.title.x = element_text(size = 14))+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  theme(strip.text.x = element_text(size = 14))+
  scale_y_discrete(labels = c('m79','m54','m41','m26','m23','m21','m19','m17','m13','m4'))+
  ylab("Clone ID")+
  scale_x_continuous(breaks = c(-0.05, -0.025, 0, 0.025), labels = c(-1.05, -1.025, 1, 1.025))+
  xlab("Relative change")+
  ggtitle("umax")+
  scale_color_manual(values = "grey25")
  
plotLag <- plot_summs(lag, robust = T, plot.distributions = TRUE, colors = '#3C5488')+
  theme_bw()+
  theme(legend.position = 'none')+
  theme(axis.ticks.length = unit(.25, "cm"))+
  theme(axis.text = element_text(size = 14), axis.title.y = element_text(size = 14), axis.title.x = element_text(size = 14))+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  theme(strip.text.x = element_text(size = 14))+
  scale_y_discrete(labels = c('m79','m54','m41','m26','m23','m21','m19','m17','m13','m4'))+
  ylab("Clone ID")+
  scale_x_continuous(breaks = c(-2, -1.5, -1, -0.5, 0), labels = c(-3, -2.5, -2, -1.5, 1))+
  xlab("Relative change")+
  ggtitle("lag")+
  scale_color_manual(values = "grey25")

(plotUmax+theme(axis.title.x=element_blank()))+
  
(plotK+theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank()))+
  
(plotLag+theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(), 
        axis.title.x=element_blank()))
```

## Stats - Canan - BAYESIAN 
```{r}
# Clones as fixed factors
# K
bayesdata <- treats_param
bayesdata$clone <- factor(bayesdata$clone, levels = c("ancestor", 
           "m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26"))

get_prior(A ~ 0 + clone, data = bayesdata, family = gaussian())

prior1 <- prior(student_t(3, 0, 2.5), class = sigma)

m1K <- brm(A ~ clone, data = bayesdata,
          family = "gaussian", prior = prior1)
summary(m1K)
posterior_summary(m1K)

rr <- rope_range(m1K)
#-0.1 * sd(y), 0.1 * sd(y)
result1K <- describe_posterior(m1K, centrality = c("median", "mean"),
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
            test = c("equivalence_test", "p_direction", "p_significance"),
                          rope_range = rr, 
                          diagnostic = "Rhat")
result2K <- equivalence_test(m1K, 
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                          rope_range = rr,
                          sort = NULL)
plot(result2K)

# umax
m1umax <- brm(umax ~ clone, data = bayesdata,
          family = "gaussian", prior = prior1)
summary(m1umax)
posterior_summary(m1umax)

rr2 <- rope_range(m1umax)
result1umax <- describe_posterior(m1umax, centrality = c("median", "mean"),
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                test = c("equivalence_test", "p_direction", "p_significance"),
                          rope_range = rr2, 
                          diagnostic = "Rhat")
result2umax <- equivalence_test(m1umax, 
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                          rope_range = rr2)
plot(result2umax)

# L
m1L <- brm(L ~ clone, data = bayesdata,
          family = "gaussian", prior = prior1)
summary(m1L)
posterior_summary(m1L)

rr3 <- rope_range(m1L)
result1L <- describe_posterior(m1L, centrality = c("median", "mean"),
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                    test = c("equivalence_test", "p_direction", "p_significance"),
                          rope_range = rr3, 
                          diagnostic = "Rhat")
result2L <- equivalence_test(m1L, 
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                          rope_range = rr3)
plot(result2L)


#Mutatios as fixed, clones as random factors

get_prior(umax ~ 0 + mutation + (1|clone), data = bayesdata, family = gaussian())

prior2 <- c(prior(student_t(3, 0, 2.5), class = sigma), 
            prior(student_t(3, 0, 2.5), class = sd))

m2K <- brm(A ~ mutation + (1|clone), data = bayesdata,
          family = "gaussian", prior = prior2)
summary(m2K)
posterior_summary(m2K)

rrR <- rope_range(m2K)
#-0.1 * sd(y), 0.1 * sd(y)
result2KR <- describe_posterior(m2K, centrality = c("median", "mean"),
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
            test = c("equivalence_test", "p_direction", "p_significance"),
                          rope_range = rrR, 
                          diagnostic = "Rhat")
result2KR <- equivalence_test(m2K, 
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                          rope_range = rrR, 
                          effects = "all")
plot(result2KR)

# umax
m2umax <- brm(umax ~ mutation + (1|clone), data = bayesdata,
          family = "gaussian", prior = prior2)
summary(m2umax)
posterior_summary(m2umax)

rr3 <- rope_range(m2umax)
result1umaxR <- describe_posterior(m2umax, centrality = c("median", "mean"),
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                test = c("equivalence_test", "p_direction", "p_significance"),
                          rope_range = rr3, 
                          diagnostic = "Rhat")
result2umaxR <- equivalence_test(m2umax, 
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                          rope_range = rr3,
                          effects = "all")
plot(result2umaxR)

# L
m2L <- brm(L ~ mutation + (1|clone), data = bayesdata,
          family = "gaussian", prior = prior2)
summary(m2L)
posterior_summary(m2L)

rr4 <- rope_range(m2L)
result2LR <- describe_posterior(m2L, centrality = c("median", "mean"),
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                    test = c("equivalence_test", "p_direction", "p_significance"),
                          rope_range = rr4, 
                          diagnostic = "Rhat")
result2LR <- equivalence_test(m2L, 
                          rope_ci = 0.95, 
                          ci = 0.95,
                          ci_method = "HDI", 
                          rope_range = rr4, 
                          effects = "all")
plot(result2LR)
```

## Stats - Custom plots BAYESIAN - Canan
```{r}
mytheme <-  theme_bw()+
  theme(legend.position = 'none')+
  theme(axis.ticks.length = unit(.25, "cm"))+
  theme(legend.text = element_text(size=12))+
  theme(axis.text = element_text(size = 14), axis.title.y = element_text(size = 14), axis.title.x = element_text(size = 14))+
  #theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  theme(strip.text.x = element_text(size = 14))

color_scheme_set("blue")

pars <- c("b_clonem26", "b_clonem23", "b_clonem54", "b_clonem41", "b_clonem21", "b_clonem19", "b_clonem17", "b_clonem79", "b_clonem13", "b_clonem4")

#labels are messed up
#labels <- c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26")

posteriorK1 <- as.array(m1K)
posteriorumax1 <- as.array(m1umax)
posteriorL1 <- as.array(m1L)

#K
K1 <- mcmc_areas(posteriorK1, pars = pars,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m1K), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m1K)[1], xmax = rope_range(m1K)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  #scale_y_discrete(labels = labels)+
  scale_x_continuous(breaks = c(-0.1, 0, 0.1), labels = c(-1.1, 1, 1.1))+
  xlab("Relative change")+
 ggtitle("K - posterior distributions",
"medians and 95% credible intervals(CI)")+
  mytheme
ggsave("K-clones.pdf", K1, height = 5, width = 5)

#umax
umax1 <- mcmc_areas(posteriorumax1, pars = pars,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m1umax), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m1umax)[1], xmax = rope_range(m1umax)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  #scale_y_discrete(labels = labels)+
  #scale_x_continuous(breaks = c(-0.05, 0.1, 0, 0.05, 0.1), labels = c(-1.05, 1.1, 1, 1.05, 1.1))+
  xlab("Relative fitness")+
  ggtitle("µmax-posterior distributions",
"medians and 95% credible intervals (CI)")+
mytheme
ggsave("umax-clones.pdf", umax1, height = 5, width = 5)

#umax intervals
umax1 <- mcmc_intervals(posteriorumax1, pars = pars,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m1umax), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m1umax)[1], xmax = rope_range(m1umax)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  #scale_y_discrete(labels = labels)+
  #scale_x_continuous(breaks = c(-0.05, 0.1, 0, 0.05, 0.1), labels = c(-1.05, 1.1, 1, 1.05, 1.1))+
  xlab("Relative fitness")+
  ggtitle("µmax-posterior distributions",
"medians and 95% credible intervals (CI)")+
mytheme
ggsave("umax-clones.pdf", umax1, height = 5, width = 5)

#L
lag1 <- mcmc_areas(posteriorL1, pars = pars,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m1L), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m1L)[1], xmax = rope_range(m1L)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  #scale_y_discrete(labels = labels)+
  scale_x_continuous(breaks = c(-3, -2, -1, 0, 1), labels = c(-4, -3, -2, 1, 2))+
  xlab("Relative change")+
  ggtitle("lag - posterior distributions",
"medians and 95% credible intervals (CI)")+mytheme
ggsave("lag-clones.pdf", lag1, height = 5, width = 5)
```

## Bayesian Random effect plots - Canan
```{r}
posteriorK2 <- as.array(m2K)
posteriorumax2 <- as.array(m2umax)
posteriorL2 <- as.array(m2L)

pars_random <- c("r_clone[m4,Intercept]", "r_clone[m13,Intercept]", "r_clone[m79,Intercept]", 
                 "r_clone[m17,Intercept]", "r_clone[m19,Intercept]", "r_clone[m21,Intercept]", 
                 "r_clone[m41,Intercept]", "r_clone[m54,Intercept]", "r_clone[m23,Intercept]",
                 "r_clone[m26,Intercept]")

pars_fixed  <- rev(c("b_mutation3","b_mutation2","b_mutation4"))

fixed_labels <- rev(c("spore", "sinR","ywcC/slrR"))
random_labels <- rev(c('m26','m23','m54','m41','m21','m19','m17','m79','m13','m4'))

#K - random

K2_random <- mcmc_areas(posteriorK2, pars = pars_random,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m2K), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m2K)[1], xmax = rope_range(m2K)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  scale_y_discrete(labels = random_labels)+
  xlab("Estimate")+
  ggtitle("K - random effects")+mytheme
ggsave("K-mutation-random.pdf", K2_random , height = 5, width = 5)

# K - fixed
K2_fixed <- mcmc_areas(posteriorK2, pars = pars_fixed,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m2K), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m2K)[1], xmax = rope_range(m2K)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  scale_y_discrete(labels = fixed_labels)+
  scale_x_continuous(breaks = c(-0.2, 0, 0.2), labels = c(-1.2, 2, 1.2))+
  xlab("Relative change")+
  ggtitle("K - fixed effects")+mytheme
ggsave("K-mutation-fixed.pdf", K2_fixed , height = 5, width = 5)

# umax - random
umax2_random <- mcmc_areas(posteriorumax2, pars = pars_random,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m2umax), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m2umax)[1] , xmax = rope_range(m2umax)[2] , ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  scale_y_discrete(labels = random_labels)+
  xlab("Relative fitness")+
  ggtitle("µmax - random effects")+mytheme
ggsave("umax-mutation-random.pdf", umax2_random , height = 5, width = 5)

# mumax - fixed
umax2_fixed <- mcmc_areas(posteriorumax2, pars = pars_fixed,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m2umax), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m2umax)[1], xmax = rope_range(m2umax)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  scale_y_discrete(labels = fixed_labels)+
  scale_x_continuous(breaks = c(-0.2, -0.1, 0, 0.1, 0.2), labels = c(-1.2, -1.1, 1, 1.1, 1.2))+
  xlab("Relative fitness")+
  ggtitle("µmax - fixed effects")+mytheme
ggsave("umax-mutation-fixed.pdf", umax2_fixed , height = 5, width = 5)

# L - random
lag2_random <- mcmc_areas(posteriorL2, pars = pars_random,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m2L), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m2L)[1] , xmax = rope_range(m2L)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  scale_y_discrete(labels = random_labels)+
  xlab("Relative change")+
  ggtitle("lag - random effects")+mytheme
ggsave("lag-mutation-random.pdf", lag2_random , height = 5, width = 5)

# L - fixed
lag2_fixed <- mcmc_areas(posteriorL2, pars = pars_fixed,
  prob = 0.95, # 95% intervals
  prob_outer = 1)+
  geom_vline(xintercept = rope_range(m2L), linetype = "dashed", color = "grey25")+
  annotate("rect", xmin = rope_range(m2L)[1], xmax = rope_range(m2L)[2], ymin = -Inf, ymax = Inf,
           alpha = .2,fill = "grey")+
  
  scale_y_discrete(labels = fixed_labels)+
  scale_x_continuous(breaks = c(-3, -2, -1, 0, 1), labels = c(-4, -3, -2, 1, 2))+
  xlab("Relative change")+
  ggtitle("lag - fixed effects")+mytheme
ggsave("lag-mutation-fixed.pdf", lag2_fixed , height = 5, width = 5)

```

## Models with rjags - Don -> Goes to the manuscript
```{r}
####load the data####
input_dat <- read.csv("~/Github/SporMut/code/4.GrowthCurves/data/comp_data.csv")
head(input_dat)
####load the data####
#grab the clone names
clns<-c("ancestor","M26","M23","M54","M41","M21","M19","M17","M79","M13","M4")

dat_order<-c(1:6,unlist(lapply(paste0("^",clns[-1],"_"),function(x)grep(x,input_dat$Curve))))
ord_list<-rep(clns,each=6)

#put this is form this code used previously
dat<-split(input_dat[dat_order,-1],f=factor(ord_list,levels = clns))

#set up data for analyses
var.mat<-data.frame(sapply(dat,"[",7))^2
#make weights based on inverse variance within clones
wts_mat<-sweep(1/var.mat,MARGIN = 2,STATS =colSums(1/var.mat) ,FUN = "/")

#find weighted means
apply(as.data.frame(sapply(dat,"[",6))*as.matrix(wts_mat),2,sum)
####
#plot raw: these are not the real mean and se because each point has
#different amounts of uncertainty that we cannot just throw away.
naive_mean<-apply(as.data.frame(sapply(dat,"[",6)),2,mean)
naive_se<-apply(as.data.frame(sapply(dat,"[",6)),2,sd)/sqrt(6)
plt_naive<-t(rbind(naive_mean-1.96*naive_se,naive_mean,naive_mean+1.96*naive_se))
plot(plt_naive[11:2,2],1:10,ylab="clone",xlab='naive estimate of umax',
     xlim=c(0.01,.16),yaxt='n',pch=21,bg=16,bty='n',main=bquote(mu*'max'))
for(i in 11:2)points(dat[[i]]$umax,rep(12-i,6),pch=21,col="skyblue",bg="skyblue")
points(plt_naive[11:2,2],1:10,pch=21,bg=16)
arrows(plt_naive[11:2,2],1:10,plt_naive[11:2,1],1:10,length = 0)
arrows(plt_naive[11:2,2],1:10,plt_naive[11:2,3],1:10,length = 0)
abline(v=1,lty=2)
axis(side = 2,at=1:10,labels = clns[11:2],las=2)
####

#create a long-form data.frame for later use
umax_df<-data.frame(umax=stack(as.data.frame(sapply(dat,"[",6)))$values,                            lvl=as.factor(sapply(strsplit(as.character(stack(as.data.frame(sapply(dat,"[",6)))$ind),"\\."),"[",1)))
                    
# now let's do it bayes-style. from what I gather from the code, the sampling is simply done using the 6
# replicates for each clone and the ancestor. So, I will do that I will assume that the umax for each rep (for each clone)
# is sampling a population mean. in addition, will use the umax_se to define weights

#make a jags model that estimates a umax for the replicates of clones and the ancestor,
# using the weights the estimates. we will sample a log-normal dist for umax to make
# sure the estimates are all positive during sampling and assume each clone is sampling a dist
# with unique variance
mod<-"model{
     for(i in 1:6){
       for(j in 1:10){
       #here is the model for each clone
       M_mu[i,j]~dlnorm(mu_m[j],tau_m[j]*wts_m[i,j])
       #M_mu[i,j]~dlnorm(mu_m[j],tau_m[j])
       }
       #here is the model of the ancestor
      An_mu[i]~dlnorm(mu_a,tau_a*wts_a[i])
      #An_mu[i]~dlnorm(mu_a,tau_a)
     }
     #priors
     for(i in 1:10){
      mu_m[i]~dnorm(0,.001)
      tau_m[i]~dgamma(.01,.01)
     }
     mu_a~dnorm(0,.001)
     tau_a~dgamma(.01,.01)
     
}"     
#Fit it
#gather data to feed jags
jdat<-list("M_mu"=as.data.frame(sapply(dat,"[",6))[,-1],"An_mu"=dat[['ancestor']]$umax,"wts_m"=wts_mat[,2:11],"wts_a"=wts_mat[,1])
#build the model object
jmod<-jags.model(textConnection(mod),n.chains = 4,data = jdat,n.adapt = 1000)
#update it
update(jmod,1000)
#sample it
ans<-coda.samples(jmod,c("mu_m","mu_a"),10000)
#look at plot to make sure they converge
#plot(ans)
#the samples look great so sets peek at the summaries of the posterior dists
summ<-summary(ans)
#check out the median of the posterior estimates
# we exponentiate them because we used a log-normal
exp(summ$quantiles)

#lets compare these medians with the simple weighted means
exp(summ$quantiles[,"50%"])
apply(as.data.frame(sapply(dat,"[",6))*as.matrix(wts_mat),2,sum)
#nice. all makes sense and is working

##Let's calcuate the relative fitness across all chains

#combine all of the chains 
vals<-rbind(as.matrix(ans[[1]]),as.matrix(ans[[2]]),as.matrix(ans[[3]]),as.matrix(ans[[4]]))
#find the quartiles of the relative fitness
apply(vals,2,function(x)median(exp(x)))
#as another check on our code, these should duplicate what we saw in the summary step above
exp(summ$quantiles[,"50%"])
#bingo!

#calc relative fitness for rest of clones and plot them in a style
#similar to umax-clones.pdf
plt_qnts<-matrix(0,10,3)
rownames(plt_qnts)<-clns[-1]
colnames(plt_qnts)<-c("2.5%","50%","97.5%")
for(i in 1:10)plt_qnts[i,]<-quantile(exp(vals[,i+1])/exp(vals[,1]),c(.025,.5,.975))

abs_val <-matrix(0,11,3)
rownames(abs_val)<-clns
colnames(abs_val)<-c("2.5%","50%","97.5%")
for(i in 1:11)abs_val[i,]<-quantile(exp(vals[,i]),c(.025,.5,.975))

#(0.8615720+0.8223441)/2
#(0.6417162+0.6015644)/2
#(1.1520816/1.1154578)/2
#(0.8857826+  1.0959868+ 0.7142084 +0.6022107+0.6993294)/5
#(0.6771939+0.8612130+0.5471092+0.4615733+0.5109680)/5
#(0.5159474 + 0.6714936 + 0.4180423 + 0.3519553 + 0.3694591)/5

#(0.9319655+0.4950823+0.5628965)/3
#(1.1811232+0.6485473+0.7213804)/3
#(1.5009746+0.8493737+0.9197495)/3

#(0.4950823+0.5628965)/2
#(0.6485473+0.7213804)/2
#(0.8493737+0.9197495)/2

#make the relative fitness vs close plots
plot(plt_qnts[10:1,2],1:10,ylab="clone",xlab='Relative fitness',
     xlim=c(0,2),yaxt='n',pch=21,bg=16,bty='n',main=bquote(mu*'max'))
arrows(plt_qnts[10:1,2],1:10,plt_qnts[10:1,1],1:10,length = 0)
arrows(plt_qnts[10:1,2],1:10,plt_qnts[10:1,3],1:10,length = 0)
abline(v=1,lty=2)
axis(side = 2,at=1:10,labels = clns[11:2],las=2)


# Jay's theme
mytheme <- theme_bw()+
  theme(axis.ticks.length = unit(.25, "cm"))+
  theme(legend.text = element_text(size=12))+
  theme(axis.text = element_text(size = 14), axis.title.y = element_text(size = 14), 
        axis.title.x = element_text(size = 14))+
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
      panel.border = element_rect(fill=NA, colour = "black", 
size=1))+
theme(strip.text.x = element_text(size = 14))+
  theme(legend.title=element_blank())+
  theme(panel.border = element_rect(fill=NA, colour = "black", 
size=1)) +
theme(axis.text.x.top = element_blank(), axis.title.x.top = element_blank(),
        axis.text.y.right = element_blank(), axis.title.y.right = element_blank())+
   theme(axis.title.x = element_text(margin=margin(10,0,0)),
   axis.title.y = element_text(margin=margin(0,10,0,0)),
   axis.text.x = element_text(margin=margin(10,0,0,0)),
   axis.text.y = element_text(margin=margin(0,10,0,0)))


#ggplot
umax_post<-as.data.frame(plt_qnts)
umax_post$clones<-c("m26", "m23", "m54", "m41", "m21", "m19", "m17", "m79", "m13", "m4")
umax_post$clones <- factor(umax_post$clones, c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26"))

umaxplot <- ggplot(umax_post, aes(y = clones, x = umax_post[,2], group = clones))+
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey25")+
  geom_errorbar(aes(xmin =umax_post[,1], xmax =umax_post[,3]), width = 0, size =1, color = "darkblue")+
   geom_point(size = 4, shape = 21, color = "darkblue", fill = "white")+
  mytheme+
  xlab("Relative fitness")+
  ggtitle(expression( ~ mu * "max d"^-1))+
   #scale_y_discrete(labels = c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26"))+
  theme(axis.title.y = element_blank())
ggsave("umaxJags-rel.pdf", umaxplot, width = 5, height = 6)

#plot as distribution
data_df <- as.data.frame(exp(vals))
data_df_rel <- data_df[,2:11]/data_df[,1]
names(data_df_rel) <- c("m26", "m23", "m54", "m41", "m21", "m19", "m17", "m79", "m13", "m4")

data_long <- data_df_rel %>%
  pivot_longer(cols = m26:m4, names_to = "clones", values_to = "dists")

data_long$clones <- factor(data_long$clones, c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26"))

clone <- levels(data_long$clones)
clones <- c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26")

dist.umax.rel <- ggplot(data_long, aes(y = as.numeric(clones), x = dists, group = clones, 
                           fill = 0.5 - abs(0.5 - stat(ecdf))))+
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey25")+
  stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE, 
                      rel_min_height = 0.005, alpha = 0.5, scale = 2, color = "grey25" )+
  xlab("Relative µmax")+
  scale_x_continuous(limits = c(0, 2), sec.axis=dup_axis())+
  mytheme+
  theme(legend.position = c(.9,.8))+
   scale_fill_gradient(low = "white", high = "grey50",
                      name = "Tail prob.")+
  theme(axis.title.y = element_blank())+
  scale_y_continuous(breaks = 1:length(clone),
                     labels = clones,
                     sec.axis = sec_axis(~.,
                                         breaks = 1:length(clone),
                                         labels = clones))

ggsave("umax_jags_dist.pdf", dist.umax.rel, width = 5, height = 5)

```

## Don -> Coefficients - Same analysis as we did but with jags - OVERWRITES VARIABLES OF THE CHUNK ABOVE
```{r}
one_hot<-cbind(anc=rep(1,dim(umax_df)[1]),sapply(clns[-1],function(x)as.numeric(umax_df$lvl==x)))

#this model is using a Gaussian with a single variance and fitting the 
# ancestor as the intercept and each clone as a different beta coef. The same as 
# you would get from the R formula umax~clone where the ancestor is coded as the first factor in "clone"
# here we use a different version of the weights because we don't want them relative by clone 
mod_1<-"model{
     for(i in 1:n){
       y[i]~dnorm(mu[i],tau/wts[i])
       mu[i]<-inprod(X[i,],b)
     }
     #priors
     for(i in 1:11){
      b[i]~dnorm(0,.001)
     }
     tau~dgamma(.01,.01)
     
}"     
#Fit it
jdat<-list("y"=umax_df$umax,"X"=one_hot,"n"=dim(umax_df)[1],"wts"=1000*stack(var.mat)$value)
jmod_1<-jags.model(textConnection(mod_1),n.chains = 4,data = jdat,n.adapt = 1000)
update(jmod_1,1000)
#sample the betas. we will use these to reconstruct the previous graph and the umax-clones.pdf graph
umax_dif<-coda.samples(jmod_1,c("b"),10000)
summary(umax_dif)
# let's peek at the tau to make sure it is converging 
#plot(coda.samples(jmod_1,c("tau"),10000))

#next, we will use the posterior chains to create relative fitness from coefs

#I'll combine chains 
chains<-rbind(as.matrix(umax_dif[[1]]),as.matrix(umax_dif[[2]]),as.matrix(umax_dif[[3]]),as.matrix(umax_dif[[4]]))

rel_fit<-t(sapply(paste0("b[",2:11,"]"),function(x)quantile((as.matrix(chains)[,"b[1]"]+as.matrix(chains)[,x])/(as.matrix(chains)[,"b[1]"]),c(.025,.5,.975))))

rownames(rel_fit)<-clns[-1]

#plot these. they should be very similar to the last graph

plot(rel_fit[10:1,2],1:10,ylab="clone",xlab='Fitness difference',xlim=c(0,2),yaxt='n',pch=21,bg=16,bty='n',main=bquote(mu*'max'~'Version 2'))
arrows(rel_fit[10:1,2],1:10,rel_fit[10:1,1],1:10,length = 0)
arrows(rel_fit[10:1,2],1:10,rel_fit[10:1,3],1:10,length = 0)
abline(v=1,lty=2)
axis(side = 2,at=1:10,labels = clns[11:2],las=2)
#compared to the previous,method this one slightly diff variation around estimates
# the estimates themselves are very close

# ggplot
rel_fit<-as.data.frame(rel_fit)
rel_fit$clones<-c("m26", "m23", "m54", "m41", "m21", "m19", "m17", "m79", "m13", "m4")
rel_fit$clones <- factor(umax_post$clones, c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26"))

umaxplot_coef <- ggplot(rel_fit, aes(y = clones, x = rel_fit[,2], group = clones))+
  geom_vline(xintercept = 1, linetype = "dashed")+
  geom_errorbar(aes(xmin =rel_fit[,1], xmax =rel_fit[,3]), width = 0, size =1, color = "darkblue")+
   geom_point(size = 4, shape = 21, color = "darkblue", fill = "white")+
  mytheme+
  xlab("Relative fitness")+
  ggtitle(expression( ~ mu * "max d"^-1))+
  theme(axis.title.y = element_blank())
ggsave("umaxJags_coef.pdf", umaxplot_coef, width = 5, height = 6)

# Distribution style

coef_data_df <- as.data.frame(chains)
coef_data_df_rel <- (coef_data_df[2:11]+coef_data_df[,1])/coef_data_df[,1]
names(coef_data_df_rel) <- c("m26", "m23", "m54", "m41", "m21", "m19", "m17", "m79", "m13", "m4")

coef_data_long <- coef_data_df_rel %>%
  pivot_longer(cols = m26:m4, names_to = "clones", values_to = "coefficients")

coef_data_long$clones <- factor(coef_data_long$clones, c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26"))

rel_dist_plot <- ggplot(coef_data_long, aes(y = clones, x = coefficients, group = clones, 
                           fill = 0.5 - abs(0.5 - stat(ecdf))))+
  geom_vline(xintercept = 1, color = "grey25", linetype = "dashed")+
  stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE, 
                      rel_min_height = 0.0005, alpha = 0.5, scale = 2, color = "grey50")+
  xlab("Relative fitness")+
  mytheme+
  theme(axis.title.y = element_blank())+
   scale_fill_gradient(low = "white", high = "#87CEFF",
                      name = "Tail prob.")
ggsave("umax_rel_dist_plot.pdf", rel_dist_plot, width = 5, height = 6)
```

## Yield and lag - Don's Bayes 
```{r}
# K
var.matK<-data.frame(sapply(dat,"[",5))^2
wts_matK<-sweep(1/var.matK,MARGIN = 2,STATS =colSums(1/var.matK) ,FUN = "/")
apply(as.data.frame(sapply(dat,"[",4))*as.matrix(wts_matK),2,sum)
K_df<-data.frame(K=stack(as.data.frame(sapply(dat,"[",4)))$values,                            lvl=as.factor(sapply(strsplit(as.character(stack(as.data.frame(sapply(dat,"[",4)))$ind),"\\."),"[",1)))

jdatK<-list("M_mu"=as.data.frame(sapply(dat,"[",4))[,-1],"An_mu"=dat[['ancestor']]$A,"wts_m"=wts_matK[,2:11],"wts_a"=wts_matK[,1])
jmodK<-jags.model(textConnection(mod),n.chains = 4,data = jdatK,n.adapt = 1000)
update(jmodK,1000)
ansK<-coda.samples(jmodK,c("mu_m","mu_a"),10000)

#plot(ansK)
summK<-summary(ansK)
exp(summK$quantiles)

exp(summK$quantiles[,"50%"])
apply(as.data.frame(sapply(dat,"[",4))*as.matrix(wts_matK),2,sum)

valsK<-rbind(as.matrix(ansK[[1]]),as.matrix(ansK[[2]]),as.matrix(ansK[[3]]),as.matrix(ansK[[4]]))

apply(valsK,2,function(x)median(exp(x)))
exp(summK$quantiles[,"50%"])

plt_qntsK<-matrix(0,11,3)
rownames(plt_qntsK)<-clns
colnames(plt_qntsK)<-c("2.5%","50%","97.5%")

#It doesnt make sense to calculate relative change for the yield and lag
for(i in 1:11)plt_qntsK[i,]<-quantile(exp(valsK[,i]),c(.025,.5,.975))

#plot the results 
plt_qnts_datK <- as.data.frame(plt_qntsK)
plt_qnts_datK$clones <- rownames(plt_qnts_datK)

plt_qnts_datK$clones <- factor(plt_qnts_datK$clones, c("M4", "M13", "M79", "M17", "M19", "M21", "M41", "M54", "M23", "M26", "ancestor"))

Kplot <- ggplot(plt_qnts_datK, aes(y = clones, x = plt_qnts_datK[,2], group = clones)) + geom_point(size = 4, shape = 21, color = "darkblue", fill = "white")+
  geom_errorbar(aes(xmin =plt_qnts_datK[,1], xmax =plt_qnts_datK[,3]), width = 0, size =1, color = "darkblue")+
   
  mytheme+
  xlab("Maximum yield")+
   scale_y_discrete(labels = c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26", "ancestor")) +
  theme(axis.title.y = element_blank())
ggsave("KJags.pdf", Kplot, width = 5, height = 6)

# Distribution version

#here I'll calculate relative 
#plot as distribution
distK_data <- as.data.frame(exp(valsK))
names(distK_data) <- clns

dataK_df_rel <- distK_data[,2:11]/(distK_data[,1])
names(dataK_df_rel) <- clns[-1]

distK_data_long <- dataK_df_rel %>%
  pivot_longer(cols = M26:M4, names_to = "clones", values_to = "dists")

distK_data_long$clones <- factor(distK_data_long$clones, c("M4", "M13", "M79", "M17", "M19", "M21", "M41", "M54", "M23", "M26", "ancestor"))

clone <- levels(distK_data_long$clones)[-11]
clones <- c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26")

Kdist <- ggplot(distK_data_long, aes(y = as.numeric(clones), x = dists, group = clones, 
                           fill = 0.5 - abs(0.5 - stat(ecdf))))+
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey25")+
  stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE, 
                      rel_min_height = 0.005, alpha = 0.5, scale = 2, color = "grey25")+
 
  xlab("Relative yield")+
  scale_x_continuous(limits = c(0.2, 2), sec.axis=dup_axis())+
  mytheme+
   theme(legend.position = c(.9,.8))+
   theme(axis.title.y = element_blank())+
   scale_fill_gradient(low = "white", high = "grey50",
                      name = "Tail prob.")+
 scale_y_continuous(breaks = 1:length(clone),
                     labels = clones,
                     sec.axis = sec_axis(~.,
                                         breaks = 1:length(clone),
                                         labels = clones))
 
ggsave("Kjags_dist.pdf", Kdist, width = 5, height = 5)
  

# lag
var.mat.lag<-data.frame(sapply(dat,"[",9))^2
wts_mat.lag<-sweep(1/var.mat.lag,MARGIN = 2,STATS =colSums(1/var.mat.lag) ,FUN = "/")
apply(as.data.frame(sapply(dat,"[",8))*as.matrix(wts_mat.lag),2,sum)

lag_df<-data.frame(lag=stack(as.data.frame(sapply(dat,"[",8)))$values,                       lvl=as.factor(sapply(strsplit(as.character(stack(as.data.frame(sapply(dat,"[",8)))$ind),"\\."),"[",1)))

jdat.lag<-list("M_mu"=as.data.frame(sapply(dat,"[",8))[,-1],"An_mu"=dat[['ancestor']]$L,"wts_m"=wts_mat.lag[,2:11],"wts_a"=wts_mat.lag[,1])
jmod.lag<-jags.model(textConnection(mod),n.chains = 4,data = jdat.lag,n.adapt = 1000)
update(jmod.lag,1000)
ans.lag<-coda.samples(jmod.lag,c("mu_m","mu_a"),10000)

#plot(ans.lag)
summ.lag<-summary(ans.lag)
exp(summ.lag$quantiles)

exp(summ.lag$quantiles[,"50%"])
apply(as.data.frame(sapply(dat,"[",8))*as.matrix(wts_mat.lag),2,sum)

vals.lag<-rbind(as.matrix(ans.lag[[1]]),as.matrix(ans.lag[[2]]),as.matrix(ans.lag[[3]]),as.matrix(ans.lag[[4]]))

apply(vals.lag,2,function(x)median(exp(x)))
exp(summ.lag$quantiles[,"50%"])

plt_qnts.lag<-matrix(0,11,3)
rownames(plt_qnts.lag)<-clns
colnames(plt_qnts.lag)<-c("2.5%","50%","97.5%")
for(i in 1:11)plt_qnts.lag[i,]<-quantile(exp(vals.lag[,i]),c(.025,.5,.975))

#plot the results 
plt_qnts_dat.lag <- as.data.frame(plt_qnts.lag)
plt_qnts_dat.lag$clones <- rownames(plt_qnts_dat.lag)

plt_qnts_dat.lag$clones <- factor(plt_qnts_dat.lag$clones, c("M4", "M13", "M79", "M17", "M19", "M21", "M41", "M54", "M23", "M26", "ancestor"))

lagplot <- ggplot(plt_qnts_dat.lag, aes(y = clones, x = plt_qnts_dat.lag[,2], group = clones)) +
  geom_errorbar(aes(xmin =plt_qnts_dat.lag[,1], xmax =plt_qnts_dat.lag[,3]), width = 0, size =1, color = "darkblue")+
   geom_point(size = 4, shape = 21, color = "darkblue", fill = "white")+
  mytheme+
  xlab("Lag time")+
  ggtitle("lag")+
   scale_y_discrete(labels = c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26", "ancestor")) +
  theme(axis.title.y = element_blank())
ggsave("lagJags.pdf", lagplot, width = 5, height = 6)

# Distribution version

#plot as distribution
distL_data <- as.data.frame(exp(vals.lag))
names(distL_data) <- clns

datalag_df_rel <- distL_data[,2:11]/(distL_data[,1])
names(datalag_df_rel) <- clns[-1]

distL_data_long <- datalag_df_rel %>%
  pivot_longer(cols = M26:M4, names_to = "clones", values_to = "dists")

distL_data_long$clones <- factor(distL_data_long$clones, c("M4", "M13", "M79", "M17", "M19", "M21", "M41", "M54", "M23", "M26"))

clone <- levels(distL_data_long$clones)
clones <- c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26")

Ldist <- ggplot(distL_data_long, aes(y = as.numeric(clones), x = dists, group = clones, 
                           fill = 0.5 - abs(0.5 - stat(ecdf))))+
   geom_vline(xintercept = 1, color = "grey25", linetype = "dashed")+
  stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE, 
                      rel_min_height = 0.005, alpha = 0.5, scale = 0.6, color = "grey25" )+
  theme(axis.title.y = element_blank())+
  
  xlab("Relative lag time")+
  mytheme+
     theme(legend.position = c(.9,.8))+
   theme(axis.title.y = element_blank())+
  scale_x_continuous(limits = c(0, 2), sec.axis=dup_axis())+
   scale_fill_gradient(low = "white", high = "grey50",
                      name = "Tail prob.")+
  scale_y_continuous(breaks = 1:length(clone),
                     labels = clones,
                     sec.axis = sec_axis(~.,
                                         breaks = 1:length(clone),
                                         labels = clones))
 

ggsave("lag_jags_dist.pdf", Ldist, width = 5, height = 5)

  ```

## Coefficients - Bayes version - Don - Overwrites some of the previous variables
```{r}
#Do the same analysis but in the way that Lennon Lab did it
#Next I will do this with the long-form data

var.matK<-data.frame(sapply(dat,"[",5))^2
wts_matK<-sweep(1/var.matK,MARGIN = 2,STATS =colSums(1/var.matK) ,FUN = "/")
apply(as.data.frame(sapply(dat,"[",4))*as.matrix(wts_matK),2,sum)
K_df<-data.frame(K=stack(as.data.frame(sapply(dat,"[",4)))$values,                            lvl=as.factor(sapply(strsplit(as.character(stack(as.data.frame(sapply(dat,"[",4)))$ind),"\\."),"[",1)))

#set up data for one-hot coding
one_hotK<-cbind(ancestor=rep(1,dim(K_df)[1]),sapply(clns[-1],function(x)as.numeric(K_df$lvl==x)))

#this model is using a Gaussian with a single variance and fitting the 
# ancestor as the intercept and each clone as a different beta coef. The same as 
# you would get from the R formula umax~clone where the ancestor is coded as the first factor in "clone"
# here we use a different version of the weights because we don't want them relative by clone 
mod_1<-"model{
     for(i in 1:n){
       y[i]~dnorm(mu[i],tau/wts[i])
       mu[i]<-inprod(X[i,],b)
     }
     #priors
     for(i in 1:11){
      b[i]~dnorm(0,.001)
     }
     tau~dgamma(.01,.01)
     
}"     
#Fit it

jdatK<-list("y"=K_df$K,"X"=one_hotK,"n"=dim(K_df)[1],"wts"=1000*stack(var.matK)$value)
jmod_1<-jags.model(textConnection(mod_1),n.chains = 4,data = jdatK,n.adapt = 1000)
update(jmod_1,1000)
#sample the betas. we will use these to reconstruct the previous graph and the umax-clones.pdf graph
K_dif<-coda.samples(jmod_1,c("b"),10000)
summary(K_dif)
# let's peek at the tau to make sure it is converging 
#plot(coda.samples(jmod_1,c("tau"),10000))

#next, we will use the posterior chains to create relative fitness from coefs
Kvals<-rbind(as.matrix(K_dif[[1]]),as.matrix(K_dif[[2]]),as.matrix(K_dif[[3]]),as.matrix(K_dif[[4]]))
coef_fitK <-t(sapply(paste0("b[",2:11,"]"),function(x)quantile((as.matrix(K_dif)[,"b[1]"]+as.matrix(K_dif)[,x]),c(.025,.5,.975))))

anq <- quantile(as.matrix(K_dif[,"b[1]"]),c(.025,.5,.975))
coef_fitK_an <- rbind(anq, coef_fitK)

rownames(coef_fitK_an)<-clns

coef_fitK_an_dat <- as.data.frame(coef_fitK_an)
coef_fitK_an_dat$clones <- rownames(coef_fitK_an_dat)
coef_fitK_an_dat$clones <- factor(coef_fitK_an_dat$clones, c("M4", "M13", "M79", "M17", "M19", "M21", "M41", "M54", "M23", "M26", "ancestor"))

Kcoefplot <- ggplot(coef_fitK_an_dat, aes(y = clones, x = coef_fitK_an_dat[,2], group = clones))+
  geom_point(size = 4, shape = 21, color = "darkblue", fill = "white")+
  mytheme+
  geom_errorbar(aes(xmin =coef_fitK_an_dat[,1], xmax =coef_fitK_an_dat[,3]), width = 0, size =1, color = "darkblue")+
  scale_y_discrete(labels = c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26", "ancestor")) +
  xlab("Maximum yield")+
  theme(axis.title.y = element_blank())
ggsave("KJags_coef.pdf", Kcoefplot, width = 5, height = 6)

#compared to the previous,method this one slightly diff variation around estimates
# the estimates themselves are very close

#plot as distribution
coef_data <- as.data.frame(Kvals)
names(coef_data) <- clns

coef_data[,2:11] <- coef_data[,2:11] +coef_data[,1] 
coef_data_long <- coef_data %>%
  pivot_longer(cols = ancestor:M4, names_to = "clones", values_to = "coefficients")

coef_data_long$clones <- factor(coef_data_long$clones, c("M4", "M13", "M79", "M17", "M19", "M21", "M41", "M54", "M23", "M26", "ancestor"))

KcoefDist <- ggplot(coef_data_long, aes(y = clones, x = coefficients, group = clones, 
                           fill = 0.5 - abs(0.5 - stat(ecdf))))+
  stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE, 
                      rel_min_height = 0.0005, alpha = 0.5, scale = 2, color = "grey50" 
                      )+
   scale_y_discrete(labels = c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26", "ancestor")) +
  theme(axis.title.y = element_blank())+
  xlab("Relative change")+
  scale_x_continuous(limits = c(0.15,0.4))+
  mytheme+
   scale_fill_gradient(low = "white", high = "#87CEFF",
                      name = "Tail prob.")

ggsave("KJags_coef_dist.pdf", KcoefDist, width = 5, height = 6)
 

# LAG - will overwrite variables 
#set up data for one-hot coding

var.mat.lag<-data.frame(sapply(dat,"[",9))^2
wts_mat.lag<-sweep(1/var.mat.lag,MARGIN = 2,STATS =colSums(1/var.mat.lag) ,FUN = "/")
apply(as.data.frame(sapply(dat,"[",8))*as.matrix(wts_mat.lag),2,sum)
lag_df<-data.frame(lag=stack(as.data.frame(sapply(dat,"[",8)))$values,                            lvl=as.factor(sapply(strsplit(as.character(stack(as.data.frame(sapply(dat,"[",8)))$ind),"\\."),"[",1)))

#set up data for one-hot coding
one_hot_lag<-cbind(ancestor=rep(1,dim(lag_df)[1]),sapply(clns[-1],function(x)as.numeric(lag_df$lvl==x)))

jdat.lag<-list("y"=lag_df$lag,"X"=one_hot_lag,"n"=dim(lag_df)[1],"wts"=1000*stack(var.mat.lag)$value)
jmod_1<-jags.model(textConnection(mod_1),n.chains = 4,data = jdat.lag,n.adapt = 1000)
update(jmod_1,1000)
#sample the betas. we will use these to reconstruct the previous graph and the umax-clones.pdf graph
lag_dif<-coda.samples(jmod_1,c("b"),10000)
summary(lag_dif)
# let's peek at the tau to make sure it is converging 
#plot(coda.samples(jmod_1,c("tau"),10000))

#next, we will use the posterior chains to create relative fitness from coefs
lag.vals<-rbind(as.matrix(lag_dif[[1]]),as.matrix(lag_dif[[2]]),as.matrix(lag_dif[[3]]),as.matrix(lag_dif[[4]]))

lag_fit<-t(sapply(paste0("b[",2:11,"]"),function(x)quantile((as.matrix(lag.vals)[,"b[1]"]+as.matrix(lag.vals)[,x]),c(.025,.5,.975))))

anqL <- quantile(as.matrix(lag_dif[,"b[1]"]),c(.025,.5,.975))
coef_fitL_an <- rbind(anqL, lag_fit)

rownames(coef_fitL_an)<-clns

coef_fitL_an_dat <- as.data.frame(coef_fitL_an)
coef_fitL_an_dat$clones <- rownames(coef_fitL_an_dat)
coef_fitL_an_dat$clones <- factor(coef_fitL_an_dat$clones, c("M4", "M13", "M79", "M17", "M19", "M21", "M41", "M54", "M23", "M26", "ancestor"))

Lcoefplot <- ggplot(coef_fitL_an_dat, aes(y = clones, x = coef_fitL_an_dat[,2], group = clones))+
  geom_point(size = 4, shape = 21, color = "darkblue", fill = "white")+
  mytheme+
  geom_errorbar(aes(xmin =coef_fitL_an_dat[,1], xmax =coef_fitL_an_dat[,3]), width = 0, size =1, color = "darkblue")+
  scale_y_discrete(labels = c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26", "ancestor")) +
  xlab("Lag time (h)")+
  theme(axis.title.y = element_blank())
ggsave("LJags_coef.pdf", Lcoefplot, width = 5, height = 6)

#compared to the previous,method this one slightly diff variation around estimates
# the estimates themselves are very close

#plot as distribution
lag_coef <- as.data.frame(lag.vals)
names(lag_coef) <- clns

lag_coef[,2:11] <- lag_coef[,2:11] +lag_coef[,1] 
lag_coef_long <- lag_coef%>%
  pivot_longer(cols = ancestor:M4, names_to = "clones", values_to = "coefficients")

lag_coef_long$clones <- factor(coef_data_long$clones, c("M4", "M13", "M79", "M17", "M19", "M21", "M41", "M54", "M23", "M26", "ancestor"))

LcoefDist <- ggplot(lag_coef_long, aes(y = clones, x = coefficients, group = clones, 
                           fill = 0.5 - abs(0.5 - stat(ecdf))))+
  stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE, 
                      rel_min_height = 0.0005, alpha = 0.5, scale = 2, color = "grey50" 
                      )+
   scale_y_discrete(labels = c("m4", "m13", "m79", "m17", "m19", "m21", "m41", "m54", "m23", "m26", "ancestor")) +
  theme(axis.title.y = element_blank())+
  xlab("Lag time (h)")+
  #scale_x_continuous(limits = c(0.04,0.18))+
  mytheme+
   scale_fill_gradient(low = "white", high = "#87CEFF",
                      name = "Tail prob.")
 

ggsave("LJags_coef_dist.pdf", LcoefDist, width = 5, height = 6)
 
```


#  OLDER
## Wrangle into treatments - Jay's 
```{r}
# Ancestor
#anc <- parms %>% filter(evo.type == "anc") # before measuring ancestor on 11 June 23
anc <- anc.parms %>% filter(evo.type == "anc")
anc.mean <- anc %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
anc.sem <- anc %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
anc.95LL <- anc %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
anc.95UL <- anc %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

# Evolved
  ## Spore fraction
m23 <- parms %>% filter(strain == "M23")
m23.mean <- m23 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m23.sem <- m23 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m23.95LL <- m23 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m23.95UL <- m23 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

m26 <- parms %>% filter(strain == "M26")
m26.mean <- m26 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m26.sem <- m26 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m26.95LL <- m26 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m26.95UL <- m26 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

  ## Total fraction
      ### sinR mutants
m17 <- parms %>% filter(strain == "M17")
m17.mean <- m17 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m17.sem <- m17 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m17.95LL <- m17 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m17.95UL <- m17 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

m19 <- parms %>% filter(strain == "M19")
m19.mean <- m19 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m19.sem <- m19 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m19.95LL <- m19 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m19.95UL <- m19 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

m21 <- parms %>% filter(strain == "M21")
m21.mean <- m21 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m21.sem <- m21 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m21.95LL <- m21 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m21.95UL <- m21 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

m41 <- parms %>% filter(strain == "M41")
m41.mean <- m41 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m41.sem <- m41 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m41.95LL <- m41 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m41.95UL <- m41 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

m54 <- parms %>% filter(strain == "M54")
m54.mean <- m54 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m54.sem <- m54 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m54.95LL <- m54 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m54.95UL <- m54 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

      ### ywcC mutants
m4 <- parms %>% filter(strain == "M4")
m4.mean <- m4 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m4.sem <- m4 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m4.95LL <- m4 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m4.95UL <- m4 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

m13 <- parms %>% filter(strain == "M13")
m13.mean <- m13 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m13.sem <- m13 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m13.95LL <- m13 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m13.95UL <- m13 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))

m79 <- parms %>% filter(strain == "M79")
m79.mean <- m79 %>% summarize(mean_A = mean(A), mean_umax = mean(umax), 
            mean_L = mean(L))
m79.sem <- m79 %>% summarize(sem_A = sem(A), sem_umax = sem(umax), 
            sem_L = sem(L))
m79.95LL <- m79 %>% summarize(LL.95_A = LL.95(A), LL.95_umax = LL.95(umax), 
            LL.95_L = LL.95(L))
m79.95UL <- m79 %>% summarize(UL.95_A = UL.95(A), UL.95_umax = UL.95(umax), 
            UL.95_L = UL.95(L))
```

## Make figure -Jay's
```{r}
# Create plot
png(filename="~/GitHub/SporeMut/output/4.GrowthCurves/growth.umaxNEW.png",
    width = 1200, height = 800, res = 96*2) 

plot.new()
par(mar = c(7, 7, 5, 7), plt = c(0.2, 0.85, 0.45, 0.85))

# Add individuals points
anc.pt <- plot(jitter(rep(1, length(anc$umax)), amount = 0.1), anc$umax, 
      ylim = c(0.02, 0.1), xlim = c(0.5, 15), pch = 21, col = "grey75", 
      bg = "grey75",
      cex = 1.7, yaxt = "n", xaxt = "n", cex.lab = 2, cex.axis = 1.5,
      las = 1, ylab = "", xlab = "")
      box(lwd = 2)

#lwd = 2 This doesn't work on my computer -CK
# Spore mutants
points(jitter(rep(3, length(m23$umax)), amount = 0.1), m23$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)
points(jitter(rep(4, length(m26$umax)), amount = 0.1), m26$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)

# Total mutants: sinR
points(jitter(rep(6, length(m17$umax)), amount = 0.1), m17$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)
points(jitter(rep(7, length(m19$umax)), amount = 0.1), m17$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)
points(jitter(rep(8, length(m21$umax)), amount = 0.1), m21$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)
points(jitter(rep(9, length(m41$umax)), amount = 0.1), m41$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)
points(jitter(rep(10, length(m54$umax)), amount = 0.1), m54$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)

# Total mutants: ywcC 
points(jitter(rep(12, length(m4$umax)), amount = 0.1), m4$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)
points(jitter(rep(13, length(m13$umax)), amount = 0.1), m13$umax, pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)
points(jitter(rep(14, length(m79$umax)), amount = 0.1), m79$umax,pch = 21, 
       bg = "grey75", col = "grey75", lwd = 2, cex = 1.7)

# Add means
points(1, anc.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(3, m23.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2)  
points(4, m26.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(6, m17.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(7, m19.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(8, m21.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(9, m41.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(10, m54.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(12, m4.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(13, m13.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 
points(14, m79.mean[2], pch = 21, col = "black", 
       bg = "NA", lwd = 2, cex = 2) 

arrows(x0 = c(1, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14), y0 = as.numeric(c(anc.mean[2], m23.mean[2], 
      m26.mean[2], m17.mean[2], m19.mean[2], m21.mean[2], m41.mean[2], m54.mean[2], 
      m4.mean[2], m13.mean[2], m79.mean[2])), y1 = as.numeric(c(anc.95UL[2], m23.95UL[2], 
      m26.95UL[2], m17.95UL[2], m19.95UL[2], m21.95UL[2], m41.95UL[2], 
      m54.95UL[2], m4.95UL[2], m13.95UL[2], m79.95UL[2])), angle = 90, length = 0.1, lwd = 2)
       
arrows(x0 = c(1, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14), y0 = as.numeric(c(anc.mean[2], m23.mean[2], 
      m26.mean[2], m17.mean[2], m19.mean[2], m21.mean[2], m41.mean[2], m54.mean[2], 
      m4.mean[2], m13.mean[2], m79.mean[2])), y1 = as.numeric(c(anc.95LL[2], m23.95LL[2], 
      m26.95LL[2], m17.95LL[2], m19.95LL[2], m21.95LL[2], m41.95LL[2], 
      m54.95LL[2], m4.95LL[2], m13.95LL[2], m79.95LL[2])), angle = 90, length = 0.1, lwd = 2)

# Add axes
axis(side = 2, lwd.ticks = 2, cex.axis = 1.25, las = 1,
     labels = c("0.025", "0.050", "0.075", "0.100"), at = c(0.025, 0.05, 0.075, 0.100))

axis(side = 4, lwd.ticks = 2, cex.axis = 1.25, las = 1,
     at=c(0.025, 0.05, 0.075, 0.100), labels = F)

axis(side = 3, lwd.ticks = 2, cex.axis = 1, las = 1,
     at = c(1, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14), labels = F)

axis(side = 1, lwd.ticks = 2, cex.axis = 1, las = 3,
     labels = c("anc", "m23", "m26", "m17", "m19", "m21", "m41", "m54", "m4",
    "m13", "m79"), at = c(1, 3, 4, 6, 7, 8, 9, 10, 12, 13, 14), col.axis = "grey80")

# Add y-axis label
mtext(expression('Maximum growth rate (d'^-1*')'), side = 2,
      outer = FALSE, cex = 1.25, line = 4.5, adj = 0.5)

# Add x-axis labels
mtext('Ancestor', side = 1, line = 6.25, at = 1, cex = 0.95, col = "grey80")
segments(0.25, -0.047, 1.75, -0.047, col = "grey80", lwd = 2, xpd = TRUE)

mtext('Evolved', side = 1, line = 6.25, at = 8.5, cex = 0.95, col = "grey80")
segments(2.75, -0.047, 14.25, -0.047, col = "grey80", lwd = 2, xpd = TRUE)

mtext('Spore', side = 1, line = 4.5, at = 3.5, cex = 0.95, col = "grey80")
segments(2.75, -0.03, 4.25, -0.03, col = "grey80", lwd = 2, xpd = TRUE)

mtext('Total', side = 1, line = 4.5, at = 10.5, cex = 0.95, col = "grey80")
segments(5.75, -0.03, 14.25, -0.03, col = "grey80", lwd = 2, xpd = TRUE)

mtext(expression(italic("sinR")), side = 1, line = 2.95, at = 8, cex = 0.95, col = "grey80")
segments(5.75, -0.013, 10.25, -0.013, col = "grey80", lwd = 2, xpd = TRUE)

mtext(expression(italic("ywcC")), side = 1, line = 2.95, at = 13, cex = 0.95, col = "grey80")
segments(11.75, -0.013, 14.25, -0.013, col = "grey80", lwd = 2, xpd = TRUE)

# Close Plot Device
dev.off()
graphics.off()

# Show Plot
img <- readPNG("~/GitHub/SporeMut/output/4.GrowthCurves/growth.umax.png")

grid.raster(img)

```